// SPDX-FileCopyrightText: 2024 Cesanta Software Limited
// SPDX-License-Identifier: GPL-2.0-only or commercial
// Generated by Mongoose Wizard, https://mongoose.ws/wizard/

// Default mock implementation of the API callbacks

#include "mongoose_glue.h"

void glue_lock_init(void) {  // callback to initialize the MQTT semaphore
}

void glue_lock(void) {  // Lock mutex. Implement only if you use MQTT publish
}

void glue_unlock(void) {  // Unlock mutex. Implement only if you use MQTT publish
}

// Update this with the real CA for the WIZARD_MQTT_URL
#define TLS_CA \
  ""

void glue_mqtt_tls_init(struct mg_connection *c) {
  bool is_tls = mg_url_is_ssl(WIZARD_MQTT_URL);
  MG_DEBUG(("%lu TLS enabled: %s", c->id, is_tls ? "yes" : "no"));
  if (is_tls) {
    struct mg_tls_opts opts;
    memset(&opts, 0, sizeof(opts));
    opts.ca = mg_str(TLS_CA);
    opts.name = mg_url_host(WIZARD_MQTT_URL);
    mg_tls_init(c, &opts);
  }
}

// Called when we connected to the MQTT server
void glue_mqtt_on_connect(struct mg_connection *c, int code) {
  struct mg_mqtt_opts opts;
  memset(&opts, 0, sizeof(opts));
  opts.qos = 1;
  opts.topic = mg_str("device1/rx");
  mg_mqtt_sub(c, &opts);
  MG_DEBUG(("%lu code %d. Subscribing to [%.*s]", c->id, code, opts.topic.len,
            opts.topic.buf));
}

// This function gets called for every received MQTT message
void glue_mqtt_on_message(struct mg_connection *c, struct mg_str topic,
                          struct mg_str data) {
  char tmp[100];
  struct mg_mqtt_opts opts;

  mg_snprintf(tmp, sizeof(tmp), "Got [%.*s] -> [%.*s] !", topic.len, topic.buf,
              data.len, data.buf);
  MG_DEBUG(("%lu %s", c->id, tmp));

  // Send response to the TX topic
  if (g_mqtt_conn != NULL) {
    memset(&opts, 0, sizeof(opts));
    opts.topic = mg_str("device1/tx");
    opts.message = mg_str(tmp);
    mg_mqtt_pub(g_mqtt_conn, &opts);
  }
}

void glue_mqtt_on_cmd(struct mg_connection *c, struct mg_mqtt_message *mm) {
  MG_DEBUG(("%lu cmd %d qos %d", c->id, mm->cmd, mm->qos));
}

struct mg_connection *glue_mqtt_connect(mg_event_handler_t fn) {
  const char *url = WIZARD_MQTT_URL;
  struct mg_mqtt_opts opts;
  memset(&opts, 0, sizeof(opts));
  opts.clean = true;
  return mg_mqtt_connect(&g_mgr, url, &opts, fn, NULL);
}

static struct cube_lamp s_cube_lamp = {30, 42, 42, false};
void glue_get_cube_lamp(struct cube_lamp *data) {
  *data = s_cube_lamp;  // Sync with your device
}
void glue_set_cube_lamp(struct cube_lamp *data) 
{
  char tmp[20] = {0};
  struct mg_mqtt_opts opts;

  s_cube_lamp = *data; // Sync with your device

  // Send response to the TX topic
  if (g_mqtt_conn != NULL) 
  {
    memset(&opts, 0, sizeof(opts));
    sprintf(tmp, "%d, %d, %d", s_cube_lamp.hue, s_cube_lamp.saturation, s_cube_lamp.brightness);   
    opts.topic = mg_str("1/rgbled/sethsv");
    opts.message = mg_str(tmp);
    mg_mqtt_pub(g_mqtt_conn, &opts);

    memset(&opts, 0, sizeof(opts));
    sprintf(tmp, "%d", s_cube_lamp.state);   
    opts.topic = mg_str("1/rgbled/seton");
    opts.message = mg_str(tmp);
    mg_mqtt_pub(g_mqtt_conn, &opts);
  }
}

static struct round_lamp s_round_lamp = {42, 42, 42, false};
void glue_get_round_lamp(struct round_lamp *data) 
{
  *data = s_round_lamp;  // Sync with your device
}
void glue_set_round_lamp(struct round_lamp *data) 
{
  char tmp[20] = {0};
  struct mg_mqtt_opts opts;
  s_round_lamp = *data; // Sync with your device

    // Send response to the TX topic
  if (g_mqtt_conn != NULL) 
  {
    memset(&opts, 0, sizeof(opts));
    sprintf(tmp, "%d, %d, %d", s_round_lamp.hue, s_round_lamp.saturation, s_round_lamp.brightness);   
    opts.topic = mg_str("2/rgbled/sethsv");
    opts.message = mg_str(tmp);
    mg_mqtt_pub(g_mqtt_conn, &opts);

    memset(&opts, 0, sizeof(opts));
    sprintf(tmp, "%d", s_round_lamp.state);   
    opts.topic = mg_str("2/rgbled/seton");
    opts.message = mg_str(tmp);
    mg_mqtt_pub(g_mqtt_conn, &opts);
  }
}
